# List

>배열(List) 는 여러개의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조



배열이란 무엇인가?

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 아래의 예는 6개의 변수를 사용해야 하는 경우, 이를 배열로 바꾸어 사용하는 것이다.



![image-20200130233744252](C:\Users\gdr0t\TIL\assets\image-20200130233744252.png)



배열의 필요성

- 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.
- 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
- 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

## I. List의 사용법

>파이썬에서는 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성된다.



### 1. 공백 리스트 만들기

>값을 초기화 하기 전에, 변수를 미리 만들어 두어야 할 경우



1차원 배열의 선언

- 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
- 이름 : 프로그램에서 사용할 배열의 이름

```python
#1차원 배열 선언의 예
Arr = list()
Arr = []
```

1차원 배열의 접근

```python
Arr[0] = 10 #배열 Arr의 0번째 원소에 10을 저장하라
Arr[idx] = 20 #배열 Arr의 idx번째 원소에 20을 저장하라
```



##### 배열과 list의 차이점

|        |             배열              |             리스트             |
| :----: | :---------------------------: | :----------------------------: |
| 데이터 | 같은 타이브이 데이티머나 저장 | 다양한 데이터를 저장할 수 있음 |
|  크기  | 처음 지정한 후 변경할 수 없음 |   가변적으로 변경할 수 있음    |





### 2. List의 자료형

>List는 시퀀스(Sequence) 자료형이다.
>
>순서가 존재함, 인덱싱과 슬라이싱 연산 모두 적용가능



- 인덱싱(Indexing) : 시퀀스 자료형에서 하나의 요소를 인덱스 연산자를 통하여 참조하는 것

  ```python
  arr = [4, 5, 6, 7, 8, 9]
  print(arr[0])     #왼쪽에서부터 index번호가 0,1,2,3,4,5 이다. => 4가 출력
  ```

  ```
  4
  ```

  

- 슬라이싱(Slicing) : 시퀀스 자료형의 원하는 범위를 선택하는 연산

  ```python
  arr = [4, 5, 6, 7, 8, 9]
  print(arr[1:3]) #[5,6]   [종료 index는 생략이 된다.]
  print(arr[:3]) #[4,5,6]
  print(arr[1:]) #[5,6,7,8,9]
  print(arr[:]) #[4,5,6,7,8,9]
  ```

  

### 3. List로 사용가능한 함수

>List는 시퀀스(Sequence) 자료형이기 때문에 시퀀스 자료형에 사용할 수 있는 함수와 연산이 사용가능



- Sequence 자료형에 사용 가능한 함수

|  함수  |        설명        |               예시                |    결과     |
| :----: | :----------------: | :-------------------------------: | :---------: |
| len()  |     원소 개수      |           len([2,3,4])            |      3      |
|   +    |    시퀀스 연결     |         [1,2,3,] + [4,5]          | [1,2,3,4,5] |
|   *    |        반복        |             [1,2] * 2             |  [1,2,1,2]  |
|   in   |     소속하는지     |           2 in [1,2,3]            |    True     |
| not in |  소속하지 않은지   |         2 not in [1,2,3]          |    False    |
| min()  |   원소 중 최소값   |           min([1,2,3])            |      1      |
| max()  |   원소 중 최대값   |           max([1,2,3])            |      3      |
| sorted | 정렬된 리스트 반환 | a = [3,1,2]<br />print(sorted(a)) |   [1,2,3]   |



- List의 함수

|   함수   |                설명                 |               예시                |   결과    |
| :------: | :---------------------------------: | :-------------------------------: | :-------: |
|  append  |          리스트 끝에 추가           |    a = [1,2]<br />a.append(3)     |  [1,2,3]  |
| insert() |           해당위치에 삽입           |  a = [3,4,5]<br />a.insert(1,9)   | [3,9,4,5] |
|  pop()   |        특정 index 항목 삭제         |     a = [3,4,5]<br />a.pop(1)     |   [3,5]   |
| remove() | 특정 값을 삭제<br />(첫 번째요소만) |  a = [3,4,5,4]<br />a.remove(4)   |  [3,5,4]  |
| count()  |         일치하는 값의 개수          | a = [9,4,4,9,5,9]<br />a.count(9) |     3     |



### 4. List의 함축(List Comprehension)

> 수학에서 집합을 정의하는 표현식과 유사



##### 실습

>10보다 작은 짝수들의 집합을 원소로 하는 리스트



```c++
//c++
int mylist[5] = {2,3,4,5,6};
int newlist[5];
for(int cnt=0, i=0 ; i<5 ; i++){
    if(mylist[i]%2 == 0){
        newlist[cnt++]=mylist[i];
    }
}
```

```python
#python
mylist = [2,3,4,5,6]
newlist = [i for i in mylist if i%2 == 0] #if문은 생략가능, for문과 if문은 추가도 가능
```

#### python이 간결하다.





## II. Exhaustive Search

> 완전 검색방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법.



- Brue-force 혹은 Generate-and-Test 기법이라고도 불린다.
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출함.
- 일반적으로 경우의 수가 상대적으로 작을 때 유용함.
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음.
- 주어진 문제를 풀 때, 우선 완전 검색으로 접간하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함.



##### 완전 검색방법 예제

> Baby-gin 게임
>
> 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 **run**이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 **triplete**이라고 함. 이때, 6장의 카드가 run과 triplete로만 구성된 경우를 Baby-gin으로 부름



##### 방법1. 완전검색 방법

```python
# 1.고려할 수 있는 모든 경우의 수 생성하기(6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함))
# 2.앞의 3자리와 뒤의 3자리를 잘라, run와 triplete 여부를 테스트하고 최종적으로 Baby-gin을 판단함.
...
...
...
```



##### 방법2. 순열

>순열(Permutation) : 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것.
>
>서로 다른 n개 중 r개를 택하는 순열은 nPr로 표현한다.

```python
# {1,2,3}을 포함하는 모든 순열을 생성하는 함수
# 동일한 숫자가 포함되지 않았을 때, 각 자릿수 별로 loop를 이용

for i1 in rage(1,3) :
    for i2 in range(1,4) :
        if i2 != i1 :
            for i3 in range(1,4) :
                if i3 != i1 and i3 != i2 :
                    print(i1,i2,i3)
```



# III. Greedy Algorithm

> 탐욕 알고리즘이란? 최적 해를 구하는데 사용되는 근시안적인 방법



- 여러 경우 중 하나를 결정해야 할 때마다 **그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식**으로 진행하여 최정적인 해답에 도달함.
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그것들을 계속 수집하여 최종적인 해답을 만들었따고 하여, 그것이 **최적이라는 보장은 없음.**
- 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 **Greedy 접근**이 됨.



### 1. 탐욕알고리즘 수행 과정



1. 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 **부분 해 집합(Solution Set)에 추가**함

2. 실행 가능성 검사: 새로운 부분 해 집합이 실행 가능한지를 확인. 

   ​                               곧, **문제의 제약 조건을 위반하지 않는지를 검사**.

3. 해 검사 : 새로운 부분해 집합이 **문제의 해가 되는지를 확인**,

   ​               아직 전체 문제의 해가 완성되지 않았다면 **해 선택부터 다시 시작**함.

##### 탐욕 알고리즘의 예1

>상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하
>한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 리턴 하는 프로그램을 작성하시오.
>중력은 회전이 완료된 후 적용된다.
>상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자
>는 없다.
>방의 가로길이는 항상 100이며, 세로 길이도 항상 100 이다.
>즉, 상자는 최소 0, 최대 100 높이로 쌓을 수 있다.

![image-20200130234006551](C:\Users\gdr0t\TIL\assets\image-20200130234006551.png)



##### 입력

```python
# data[100] : 회전하기 전 상자들이 쌓여있는 모양을 나타내는 data.
# 앞의 예시에서는 [7,4,2,0,0,6,0,7,0]이 된다.
```

##### 사용 코드

```python
# data 배열은 랜덤하게 채워진다.
# main 함수를 작성해 보자.

def build_data(data):
    
    # form 0 to 99
    for i in range(0,100):
        data[i]
        
if __name__ == "__main__":
    int data[100]
    
    # from 0 to 9
    for i in range(0,100):
        buil_data(data)
        
        '''
        이곳에 계산하는 코드 작성
        '''
        print(_result)
```



##### 탐욕 알고리즘의 예2

> 거스름돈 줄이기
>
> 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

```python
# 1. [해 선택] 가장 좋은 해를 선택 : 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가함.
# 2. [실행가능성 검사] 거스름돈이 손님에게 내드려야 할 액수를 초과하는지를 확인.
#    초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 해 선택으로 돌아가서 현재보다 한단계 작은 동전을 #    추가함.
# 3. [해 검사] : 거스름돈이 손님에게 내드려야 하는 액수와 일치하는지 확인
#    액수에 모자라면 다시 해 선택으로 돌아가서 거스름돈에 추가할 동전을 고름.
...
...
...
```



##### 탐욕 알고리즘의 예3

> Baby-gin 게임

![image-20200130234328503](C:\Users\gdr0t\TIL\assets\image-20200130234328503.png)

```python
# 완전 검색이 아닌 탐욕 알고리즘으로 Baby-gin 방법으로 풀어보기.
# 1. 6개의 숫자는 6자리의 정수 값으로 입력됨.
# 2. Counts 리스트의 각 원소를 체크하여 run과 trplete 및 Baby-gin여부를 판단함.
# 이때 탐욕 알고리즘을 적용함
# Counts 리스트에서 run과 triplete 중에 가능한 것을 조사함
# 조사에 사용한 데이터는 삭제함
# 남은 데이터를 다시 run과 triplete 중에 가능한지를 조사함

num = 456789
c = [0]*12 #6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
for i in range(6) :
    c[num % 10] += 1
    num //= 10
i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3 : 
        c[i] -= 3
        tri += 1
        continue
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1 : #run 조사 후 데이터 삭제
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i+=1
if run + tri == 2 : print("Baby Gin")
else : print("Lose")
```



### 2. 탐욕 알고리즘 접근시 해답을 찾아내지 못할 때



1.입력 받은 숫자를 정렬한 후, 앞뒤 3자리씩 끊어서 run 및 triplete을 확인하는 고려한다 했을 때

예) [6,4,4,5,4,4]

정렬하여 [4,4,4,4,5,6]을 얻어내면 쉽게 Baby-gin을 확인 할 수 있음

예 [1,2,3,1,2,3]

정렬하면 [1,1,2,2,3,3]로서 오히려 Baby-gin 확인을 실패 할 수 있음.



**이처럼 탐욕 알고리즘적인 접근은 해답을 찾아내지 못하는 경우도 있으니 주의!**



## IV. Sort

> 정렬(Sort)이란? 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 
>
> 혹은 그 반대로 순서대로(내림차순: descending) 재배열 하는 것.
>
> 정렬에서 **key**란? 자료를 정렬하는 기준이 되는 특정 값

![image-20200130234410795](C:\Users\gdr0t\TIL\assets\image-20200130234410795.png)



## 1. 대표적인 정렬 방식의 종류

> APS 과정을 통해 자료구조와 알고리즘을 학습하면서 다양한 형태의 정렬을 학습하게 된다.



- 버블 정렬(Bubble Sort)
- 카운팅 정렬(Counting Sort)
- 선택 정렬(Selection Sort)
- 퀵 정렬(Quick Sort)
- 삽입 정렬(Insertion Sort)
- 병합 정렬(Merge Sort)



### (1) 버블 정렬(Bubble Sort)

>인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식



- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
- 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨
- 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양 같아서 버블 정렬이라 함
- 버블 정렬의 시간 복잡도는 O (n<sup>2</sup>)이다.



##### 실습 예제

> [55, 7, 78, 12, 42] 를 버블 정렬하는 과정

**첫 번째 패스*

![image-20200130234505903](C:\Users\gdr0t\TIL\assets\image-20200130234505903.png)

##### 두 번째 패스



![image-20200130234532207](C:\Users\gdr0t\TIL\assets\image-20200130234532207.png)

##### 세 번째 패스

![image-20200130234606120](C:\Users\gdr0t\TIL\assets\image-20200130234606120.png)

##### 네 번째 패스

![image-20200130234628316](C:\Users\gdr0t\TIL\assets\image-20200130234628316.png)

#####  정렬 끝

![image-20200130234638275](C:\Users\gdr0t\TIL\assets\image-20200130234638275.png)

```python
# 리스트를 활용한 버블 정렬(슈도코드로 표현)

def bubble_sort(li):
    length = len(li) - 1
    for i in range(length):
        for j in range(length-i):
            if li[j] > li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]
```





### (2) 카운팅 정렬(Counting Sort)

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 
>
> 선형 시간에 정렬하는 효율적인 알고리즘.

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
- 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 리스트를 사용하기 때문임.
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함.
- 시간 복잡도 = O(n+k) : n은 리스트의 개수, k는 정수의 최대값



##### 실습 예제

> [0,4,1,3,1,2,4,1]을 카운팅 정렬하는 과정

1. Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 리스트 Counts에 저장

   DATA = [0, 4, 1, 3, 1, 2, 4, 1]

   ![image-20200130235144655](C:\Users\gdr0t\TIL\assets\image-20200130235144655.png)
   
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTs의 원소를 조정

   ![image-20200130235215489](C:\Users\gdr0t\TIL\assets\image-20200130235215489.png)
   
   해당 원소가 정렬될 때 List에 몇번째 index에 들어가는 지를 보여줌.

3. DATA의 마지막 항목부터 원소를 정렬함. 마지막 항목의 값이 COUNTS 리스트의 인덱스 항목을 참조,

   해당 하는 값을 -1 하고 감소시킨 값의 index에 마지막 항목 원소를 넣음.

   ![image-20200130235229118](C:\Users\gdr0t\TIL\assets\image-20200130235229118.png)

4. COUNTS[4]를 감소시키고 DATA_Temp에 4를 삽입

   ![image-20200130235245834](C:\Users\gdr0t\TIL\assets\image-20200130235245834.png)

5. COUNTS[2]를 감소시키고 DATA_Temp에 2를 삽입

   ![image-20200130235300822](C:\Users\gdr0t\TIL\assets\image-20200130235300822.png)

6. COUNTS[1]을 감소시키고 DATA_Temp에 1을 삽입

   ![image-20200130235317298](C:\Users\gdr0t\TIL\assets\image-20200130235317298.png)

7. COUNTS[3]을 감소시키고 DATA_Temp에 3을 삽입

   ![image-20200130235332289](C:\Users\gdr0t\TIL\assets\image-20200130235332289.png)

8. COUNTS[1]을 감소시키고 DATA_Temp에 1을 삽입

   ![image-20200130235347008](C:\Users\gdr0t\TIL\assets\image-20200130235347008.png)

9. COUNTS[4]를 감소시키고 DATA_Temp에 4를 삽입

   ![image-20200130235404026](C:\Users\gdr0t\TIL\assets\image-20200130235404026.png)

10. COUNTS[0]를 감소시키고 DATA_Temp에 0을 삽입

    ![image-20200130235619119](C:\Users\gdr0t\TIL\assets\image-20200130235619119.png)

#####  DATA_Temp 업데이트 완료하고 정렬 작업을 종료



##### 카운팅 정렬 슈도 코드

```python
def counting_sort(array):
 	
    #max num 선언
    max_num = max(array)
    
    #counting array 생성
    counting_array = [0]*(max+1)
 
    #counting array에 input array내 원소의 빈도수 담기
    for i in array:
        counting_array[i] += 1
 
    #counting array 업데이트.
    for j in range(max):
        counting_array[j+1] += counting_array[j]
 
    #output array 생성
    output_array = [0]*len(array)
 
    #output array에 정렬하기(counting array를 참조)
    for k in array:
        output_array[counting_array[k] -1] = k
        counting_array[k] -= 1
    return output_array

a = [0, 9, 1, 3, 1, 2, 4, 1]
result = counting_sort(a)
print(result)
```



##### 버블 정렬과 카운팅 정렬 비교

![image-20200130235504096](C:\Users\gdr0t\TIL\assets\image-20200130235504096.png)

