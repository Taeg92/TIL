

# Web

​      

  

### **Goal**

- [x] **HTTP Request  종류 알아보기.**

- [x] **HTTP Response 종류 알아보기.**

- [x] **HTTP Proxy 동작 알아보기.**

  

​     

## I. HTTP Request

> HTTP Request에 대해 알아보기.

   

HTTP Request 요청 메소드란?





클라이언트가 웹 서버에게 사용자 **요청의 목적/종류를 알리는 수단**이다.

최초의 HTTP에서는 GET 메소드 하나밖에 존재하지 않았고, 당시 서버로부터의 응답은 무조건 HTML 문서였다.





### 1. 요청 종류



![](https://t1.daumcdn.net/cfile/tistory/9935CE375AE7330A15)



#### HEAD 

> 메세지 헤더(문서 정보) 취득

   

- GET과 유사한 방식이지만, 실제 문서를 요청하는 것이 아니라, 문서 정보를 요청하는 것이다.

- HTTP 응답 메세지에 본문(Body)없이 HTTP 헤더 정보만을 보냄.

  

![](https://t1.daumcdn.net/cfile/tistory/99D7853A5B34D32131)

#### **GET**

> URI 형식으로 웹 서버측 리소스(데이터)를 요청



파라미터를 넘겨서 해당하는 본문형식을 받는다.

  

![](https://t1.daumcdn.net/cfile/tistory/998AB6345B34D6E62D)



위 그림처럼 URI형식으로 서버에 요청해 데이터를 받는다. 	

그러므로 본인이 서버에 파라미터를 날릴 때 url에 찍히는 것이 보기 싫다면 POST로 요청해야한다.



#### PUT

> 내용 갱신 위주(파일 전송 가능)

   

POST처럼 정보를 서버로 제출하는 것이나 보통 갱신 위주다.



#### DELETE

> 파일 삭제

  

웹 리소스를 제거할 때 사용한다. 하지만, DELETE의 경우 서버에서 클라이언트의 요청을 무시 가능하기 때문에 실제로 삭제되지 않았지만, 

클라이언트는 파일이 삭제 되었다고 생각할 수 있다.



 #### OPTIONS

> 웹 서버측 제공 메소드에 대한 질의



가능한 메소드 옵션에 대한 질의이다.

이 경우 응답 메세지에 HTTP 헤더 항목 중 'Allow: GET, POST, HEAD'처럼 보내게 된다.



#### TRACE

> 요청 리소스가 수신되는 경로를 보여줌.

   

   자기 앞으로 요청 메세지를 반환(루프백) 시험





 #### CONNECT

> 프록시 서버와 같은 중간 서버 경유



이 메소드는 요청한 리소스에 대해 양방향 연결을 시작하는 메소드다.

CONNECT 메소드는 SSL(HTTPS)를 사용하는 웹 사이트 접속하는데 사용할 수 있다. 

클라이언트는 원하는 목적지와 TCP연결을 HTTP 프록시 서버에 요청한다. 그러면 서버는 클라이언트 대신하여 연결의 생성을 진행한다. 한번 서버에 의해 연결이 수립되면, 프록시 서버는 클라이언트에 오고가는 TCP 스트림을 계속해서 프록시한다.





전체적으로, 개발에서 **GET, POST 방식 이외에는 보안이 취약해서 사용을 권장하지 않는다.**



 

 

## II. HTTP Response

> HTTP Response에 대해 알아보기.

​    

 

#### HTTP Response란?



**서버가 보내는 응답!**



![](https://www.lesstif.com/laravelprog/files/26083972/26181741/1/1433594816000/image2015-6-6+22%3A0%3A13.png)



### 1. 상태 라인



HTTP 요청과 마찬가지로 응답에서도 첫 번째 줄이 가장 중요하며 이것을 HTTP 상태 라인(Status Line) 이라고 합니다. 응답의 상태 라인도 매우 간단하며 다음과 같은 구조로 이루어져 있습니다.



![](https://www.lesstif.com/laravelprog/files/26083972/26181742/1/1433595116000/image2015-6-6+22%3A5%3A14.png)



버전은 응답과 마찬가지로 사용하는 프로토콜의 버전을 의미합니다.

가장 중요한 부분은 상태 코드로 클라이언트가 요청한 결과가 어떻게 처리되었는지 나타냅니다. 200 은 요청이 성공해서 정상적인 응답이 돌아왔음을 나타냅니다.

여기에서는 302 라는 응답이 왔는데 이것은 컨텐츠가 다른 곳에 있으니 그리로 가라는 의미입니다. 응답 구문은 상태 코드와 동일하지만 사람이 보고 알수 있도록 문자열로 되어 있습니다.



![](https://www.ncloud24.com/img2016/newsletter/201612/201612_newsletter_025.png)



### 2. HTTP 상태 코드



**HTTP 응답 상태 코드 범주**

HTTP 표준에는 많은 상태 코드가 있지만 일반적으로 많이 볼 수 있는 상태 코드는 다음 표와 같으며 이 정도만 알아도 HTTP 관련 문제에 부딪혔을 때 해결하는데 많은 도움이 될 것입니다.



#### 대표적인 상태 코드



![](https://t1.daumcdn.net/cfile/tistory/2163EC43586A331735)



### 3. 메시지 헤더

  

상태 라인에 이어서 나오는 것은 메시지 헤더(그림중 2번)이며 두번째 줄부터 빈 줄까지 계속됩니다. 서버의 HTTP 응답 메시지 헤더의 종료는 두 개의 빈줄로 표시하며 주요 헤더는 다음과 같습니다.



**Cache-Control**

브라우저가 이 페이지를 캐쉬로 처리할 때 참고하라는 의미이며 no-cache 로 지정할 경우 캐시하지 말라는 의미입니다. no-cache 는 로그인 페이지나 관리자 페이지등 중요한 페이지일 경우 설정합니다.

  

**Content-Type**

서버가 보내는 컨텐츠의 형식을 표시하는 헤더로 정확히 설정되어야 브라우저가 컨텐츠 종류에 따라 적절하게 처리할 수 있습니다. 또 중요한 부분은 ; charset=UTF-8 이며 컨텐츠의 인코딩이 어떻게 되어 있는지를 지정합니다. 인코딩 항목이 제대로 되어 있지 않으면 브라우저 화면에서 한글이나 한자같은 비영어권 문자가  깨져 보일수 있습니다.



**Location**

서버의 응답이 컨텐츠가 다른 곳에 있다는 의미인 302 이므로 Location 헤더를 통해 가야할  URL 을 지정합니다. 301, 302 일 경우에만 볼 수 있는 헤더입니다.

 

**Server**

사용하는 웹 서버 소프트웨어의 종류와 버전을 표시합니다.

  

#### 메시지 본문

마지막은 메시지 본문으로 이 경우 HTML 파일의 내용이 그대로 들어가 있으며 텍스트이므로 우리가 직접 읽을 수 있습니다. PNG 나 GIF 같은 이미지 파일이나 동영상 파일들은 바이너리 형식이므로 피들러에서는 제대로 표시되지 않고 알수 없는 문자열로 보이게 됩니다.





## III. HTTP Proxy

   

  

### 1. Proxy Server란?

  

**Proxy Server(프록시 서버')**는 중개자이다. 

클라이언트와 서버 사이에 위치하여 그들 사이의 HTTP 메시지를 정리하는 중개인 역할을 한다. 클라이언트 입장에서 트잭잭션을 수행한다. 만약 웹 프록시서버가 없다면, 클라이언트는 HTTP 서버와 직접 통신해야 하고, 있다면 웹 프록시서버를 통해 통신하면 된다. 둘 다 트랜잭션을 완료하는 것이 클라이언트라는 점은 변하지 않지만, 프록시서버가 제공하는 여러 서비스를 이용할 수 있게 된다. 

  

### **HTTP Proxy Server**

**HTTP 프록시 서버**는 웹 서버이면서 웹 클라이언트이다. HTTP 요청을 받게 되므로, 반드시 웹 서버처럼 요청과 커넥션을 적절히 다루고 응답을 돌려줘야 한다. 동시에 요청을 서버로 요청을 보내기도 하므로 요청을 보내고 응답을 받는 올바른 HTTP 클라이언트처럼 동작해야 한다.

  

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcujQFW%2FbtqANDX5xnA%2Fa9VnRn0Z1bjsGcfhZerdK0%2Fimg.png)

   

### 2. **Proxy vs Gateway**

**프록시**는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결하고, **게이트웨이**는 서로 다른 프로토콜을 사용하는 둘 이상을 연결하며, 클라이언트와 서버가 서로 다른 프로토콜로 통신하더라도 서로 간의 트랜잭션을 완료할 수 있도록 해 준다.



![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FE7prm%2FbtqAPdRJa0o%2FNB31D600hR09cTPZ0A6Yu0%2Fimg.png)

 하지만 실무에서는 프록시와 게이트웨이의 경계가 불분명하다. 왜냐하면 브라우저와 서버는 다른 버전의 HTTP를 구현하기 때문에, 프록시는 프로토콜을 변환하기도 한다. 그리고 상용 프록시 서버는 SSL 보안 프로토콜, FTP 접근 등 웹 기반 애플리케이션을 지원하기 위해 게이트웨이의 기능을 구현한다. 

  

**Why proxy server is needed?**

 프록시 서버는 실용적이고 유용한 서비스를 제공한다. 보안을 개선하고 성능을 높여주며, 비용을 절약하게 해준다. 그리고 프록시 서버는 모든 HTTP 트래픽을 모니터링할 수 있기 때문에, 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정할 수 있다.

  

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbOxpau%2FbtqAOcsfVQI%2FWvjJRaxy9FWkhO1cXKSKRK%2Fimg.png)



 위 그림에서 프록시의 역할이 잘 표현되어 있다. 필터링(제어)를 중앙 집권적으로 프록시에서 해결할 수 있다. 어린이 필터, 문서 접근 제어, 보안 방화벽, 웹 캐시, 대리 프록시(=리버스 프록시), 콘텐츠 라우터, 트랜스코더, 익명화 프록시 등에서 사용되곤 한다. 

 

**프록시는 어디에 배치할까?**

어떻게 사용할지에 따라서 프록시는 어디에든 배치할 수 있다.

  

 

### 3.**프록시 계층**

> 프록시 서버는 연쇄적으로 구성할 수 있으며, 이를 프록시 계층이라고 한다.

  

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fscycq%2FbtqARyApOVm%2FrsUnyYRtL22NehHMJ3WQK0%2Fimg.png)

 

 위 그림은 3단계 프록시 계층을 나타낸다. 클라이언트의 요청은 부모 프록시(서버에 가까운 프록시, 클라이언트에 가까운 프록시는 자식 프록시라고 한다.)를 통해 서버로 이동한다. 그리고 서버에서 받은 응답은 다시 부모 프록시(클라이언트에 가까운 프록시, 서버에 가까운 프록시는 자식 프록시)로 이동해서 전달된다. 그리고 위 그림에서 있는 프록시 구조를 "**프록시 계층이 정적**"이다고 표현한다. 

 물론 모든 프록시 계층이 정적이지는 않다. 예를 들어 유료 서비스를 만들고, 유료 구독자에게는 일반적인 프록시 서버를 통하는 게 아니라 대형 캐시(캐시 프록시)나 성능 개선을 위한 압축 엔진(압축 프록시)으로 라우팅 되게 하는 것이다. 동적 부모 라우팅 로직은 제품(설정 파일, 스크립트 언어, 동적으로 실행 가능한 플러그인 등)에 따라 다르게 구현된다.

 

**어떻게 프록시는 트래픽을 처리할까?**

클라이언트 트래픽이 프록시로 가도록 만드는 방법은 4가지가 있다. 

 

**1. 프록시를 사용하도록 설정한 클라이언트(클라이언트를 수정)**

대중적으로 사용되는 브라우저에는 수동 혹은 자동(PAC)으로 프록시 설정을 지원한다. 이때 클라이언트는 HTTP 요청을 바로(의도적으로) 원 서버가 아닌 프록시로 보낸다.

 

**2. 트래픽을 가로채어 프록시로 리다이렉트 하는 네트워크(네트워크를 수정)**

클라이언트를 알지도 못하고 간섭도 할 수 없는 상태라면 네트워크 인프라를 가로채서 웹 트래픽을 프록시로 가도록 조정한다. 이것을 인터셉트 프록시라고 한다.

 

**3. 웹 서버를 위해 설치된 대리 프록시(DNS 이름 공간을 수정)**
웹 서버 앞에 위치하는 프록시 서버인 대리 프록시는 웹 서버의 이름과 IP 주소를 자신이 직접 사용한다. 따라서 모든 요청은 대리 프록시로 가게 된다. 

 

**4. HTTP 요청을 프록시로 리다이렉트 하는 서버(웹 서버를 수정)**

웹 서버에서 HTTP 리다이렉션 명령(305)을 클라이언트에게 돌려줌으로써 클라이언트의 요청을 프록시로 리다이렉트 하도록 설정한다. 리다이렉트를 받는 즉시 클라이언트는 프록시와의 트랜잭션을 시작한다.