

# Web

​      

  

### **Goal**

- [x] **HTTP Request  종류 알아보기.**

- [x] **HTTP Response 종류 알아보기.**

- [x] **HTTP Proxy 동작 알아보기.**

  

​     

## I. HTTP Request

> HTTP Request에 대해 알아보기.

   

HTTP Request 요청 메소드란?





클라이언트가 웹 서버에게 사용자 **요청의 목적/종류를 알리는 수단**이다.

최초의 HTTP에서는 GET 메소드 하나밖에 존재하지 않았고, 당시 서버로부터의 응답은 무조건 HTML 문서였다.





### 1. 요청 종류



![](https://t1.daumcdn.net/cfile/tistory/9935CE375AE7330A15)



#### HEAD 

> 메세지 헤더(문서 정보) 취득

   

- GET과 유사한 방식이지만, 실제 문서를 요청하는 것이 아니라, 문서 정보를 요청하는 것이다.

- HTTP 응답 메세지에 본문(Body)없이 HTTP 헤더 정보만을 보냄.

  

![](https://t1.daumcdn.net/cfile/tistory/99D7853A5B34D32131)

#### **GET**

> URI 형식으로 웹 서버측 리소스(데이터)를 요청



파라미터를 넘겨서 해당하는 본문형식을 받는다.

  

![](https://t1.daumcdn.net/cfile/tistory/998AB6345B34D6E62D)



위 그림처럼 URI형식으로 서버에 요청해 데이터를 받는다. 	

그러므로 본인이 서버에 파라미터를 날릴 때 url에 찍히는 것이 보기 싫다면 POST로 요청해야한다.



#### PUT

> 내용 갱신 위주(파일 전송 가능)

   

POST처럼 정보를 서버로 제출하는 것이나 보통 갱신 위주다.



#### DELETE

> 파일 삭제

  

웹 리소스를 제거할 때 사용한다. 하지만, DELETE의 경우 서버에서 클라이언트의 요청을 무시 가능하기 때문에 실제로 삭제되지 않았지만, 

클라이언트는 파일이 삭제 되었다고 생각할 수 있다.



 #### OPTIONS

> 웹 서버측 제공 메소드에 대한 질의



가능한 메소드 옵션에 대한 질의이다.

이 경우 응답 메세지에 HTTP 헤더 항목 중 'Allow: GET, POST, HEAD'처럼 보내게 된다.



#### TRACE

> 요청 리소스가 수신되는 경로를 보여줌.

   

   자기 앞으로 요청 메세지를 반환(루프백) 시험





 #### CONNECT

> 프록시 서버와 같은 중간 서버 경유



이 메소드는 요청한 리소스에 대해 양방향 연결을 시작하는 메소드다.

CONNECT 메소드는 SSL(HTTPS)를 사용하는 웹 사이트 접속하는데 사용할 수 있다. 

클라이언트는 원하는 목적지와 TCP연결을 HTTP 프록시 서버에 요청한다. 그러면 서버는 클라이언트 대신하여 연결의 생성을 진행한다. 한번 서버에 의해 연결이 수립되면, 프록시 서버는 클라이언트에 오고가는 TCP 스트림을 계속해서 프록시한다.





전체적으로, 개발에서 **GET, POST 방식 이외에는 보안이 취약해서 사용을 권장하지 않는다.**



 

 

## II. HTTP Response

> HTTP Response에 대해 알아보기.

​    

 

#### HTTP Response란?



**서버가 보내는 응답!**



![](https://www.lesstif.com/laravelprog/files/26083972/26181741/1/1433594816000/image2015-6-6+22%3A0%3A13.png)



### 1. 상태 라인



HTTP 요청과 마찬가지로 응답에서도 첫 번째 줄이 가장 중요하며 이것을 HTTP 상태 라인(Status Line) 이라고 합니다. 응답의 상태 라인도 매우 간단하며 다음과 같은 구조로 이루어져 있습니다.



![](https://www.lesstif.com/laravelprog/files/26083972/26181742/1/1433595116000/image2015-6-6+22%3A5%3A14.png)



버전은 응답과 마찬가지로 사용하는 프로토콜의 버전을 의미합니다.

가장 중요한 부분은 상태 코드로 클라이언트가 요청한 결과가 어떻게 처리되었는지 나타냅니다. 200 은 요청이 성공해서 정상적인 응답이 돌아왔음을 나타냅니다.

여기에서는 302 라는 응답이 왔는데 이것은 컨텐츠가 다른 곳에 있으니 그리로 가라는 의미입니다. 응답 구문은 상태 코드와 동일하지만 사람이 보고 알수 있도록 문자열로 되어 있습니다.



![](https://www.ncloud24.com/img2016/newsletter/201612/201612_newsletter_025.png)



### 2. HTTP 상태 코드



**HTTP 응답 상태 코드 범주**

HTTP 표준에는 많은 상태 코드가 있지만 일반적으로 많이 볼 수 있는 상태 코드는 다음 표와 같으며 이 정도만 알아도 HTTP 관련 문제에 부딪혔을 때 해결하는데 많은 도움이 될 것입니다.



#### 대표적인 상태 코드



![](https://t1.daumcdn.net/cfile/tistory/2163EC43586A331735)



### 3. 메시지 헤더

  

상태 라인에 이어서 나오는 것은 메시지 헤더(그림중 2번)이며 두번째 줄부터 빈 줄까지 계속됩니다. 서버의 HTTP 응답 메시지 헤더의 종료는 두 개의 빈줄로 표시하며 주요 헤더는 다음과 같습니다.



**Cache-Control**

브라우저가 이 페이지를 캐쉬로 처리할 때 참고하라는 의미이며 no-cache 로 지정할 경우 캐시하지 말라는 의미입니다. no-cache 는 로그인 페이지나 관리자 페이지등 중요한 페이지일 경우 설정합니다.

  

**Content-Type**

서버가 보내는 컨텐츠의 형식을 표시하는 헤더로 정확히 설정되어야 브라우저가 컨텐츠 종류에 따라 적절하게 처리할 수 있습니다. 또 중요한 부분은 ; charset=UTF-8 이며 컨텐츠의 인코딩이 어떻게 되어 있는지를 지정합니다. 인코딩 항목이 제대로 되어 있지 않으면 브라우저 화면에서 한글이나 한자같은 비영어권 문자가  깨져 보일수 있습니다.



**Location**

서버의 응답이 컨텐츠가 다른 곳에 있다는 의미인 302 이므로 Location 헤더를 통해 가야할  URL 을 지정합니다. 301, 302 일 경우에만 볼 수 있는 헤더입니다.

 

**Server**

사용하는 웹 서버 소프트웨어의 종류와 버전을 표시합니다.

  

#### 메시지 본문

마지막은 메시지 본문으로 이 경우 HTML 파일의 내용이 그대로 들어가 있으며 텍스트이므로 우리가 직접 읽을 수 있습니다. PNG 나 GIF 같은 이미지 파일이나 동영상 파일들은 바이너리 형식이므로 피들러에서는 제대로 표시되지 않고 알수 없는 문자열로 보이게 됩니다.