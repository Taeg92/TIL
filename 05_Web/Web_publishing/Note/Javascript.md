# 01. 변수와 상수



변수 (Variable): 언제나 변할 수 있는 값

상수(constant): 변하지 않는 값

```html
<script>
    // 변수 선언 방법
    var score = 1;
</script>
```

```html
<script>
    // 상수 선언 방법
    // 상수는 값을 선언한 이후 바꿀 수 없는 값이다.
    // const MAX_LEVEL; 값을 선언안해도 오류가 난다.
    const MAX_LEVEL = 99;
</script>
```



변수와 상수를 만들 때 이름을 아무렇게나 지으면 안 됩니다. 이름을 지을 때는 몇 가지 룰을 따라주세요!



# 꼭 지켜야 하는 룰 (지키지 않으면 오류)



(1) JavaScript 식별자는 '문자(`a`-`z`, `A`-`Z`)', '밑줄(`_`)' 혹은 '달러 기호(`$`)'로 시작해야 합니다. 두 번째 글자부터는 '숫자(`0`-`9`)'도 가능합니다.



(2) '대문자'와 '소문자'는 구별합니다. `myname`과 `myName`은 다른 이름입니다.



(3) '예약어(JavaScript가 찜해놓은 단어)'는 사용하면 안 됩니다. 예를 들어서 `if`, `for`, `var`같은 것들이 있습니다. 강의를 듣다 보면 어떤 예약어가 있는지 차차 알게 되실 겁니다.



# 지키면 좋은 룰 (더 좋은 스타일을 위해)



위에 나와 있는 룰들을 지키면 오류 없이 코드가 돌아갈 것입니다. 하지만 돌아가기만 한다고 다 좋은 코드는 아닙니다. 프로그래밍은 혼자 하는 게 아니기 때문이죠. 협업을 할 때 여럿이 일관성 있는 코드를 쓰기 위해서는 어느 정도의 약속이 필요합니다.



우리는 이 약속들을 지킵시다:



(1) 의미 없는 이름은 좋지 않습니다.



```js
var a, b, c, d;
```



향후 복잡한 프로그램을 짜게 되면 변수와 함수를 여기저기서 적절히 활용해야 하는데, 이름이 `a`, `b`, `c`, `d`처럼 의미없이 설정되어 있으면 어떤 값을 저장해뒀는지 찾기도 어렵고 활용하기도 어렵습니다. 또한 프로그램의 가독성이 떨어져서 나중에 스스로 프로그램을 살펴볼 때, 그리고 공동 작업을 할 때 매우 불편한 상황이 발생합니다. 그래서 프로그래밍 초반부터 적절한 이름을 짓는 습관을 들이는 것이 좋습니다!



(2) 너무 추상적인 이름은 좋지 않습니다.



```js
var name; // 너무 추상적인 이름
```



상황에 따라 그냥 `name`이라는 변수명이 적합한 상황도 있을 수 있겠지만, 긴 프로그램을 쓰다 보면 다양한 '이름'들이 있기 때문에 `name`은 너무 추상적일 수 있습니다. 그럴 때에는 조금 더 구체적인 이름으로 이해하기 쉽게 만들어주세요!



(3) 모든 변수 이름은 'camelCase'로 쓰는 것이 좋습니다.



변수명에는 띄어쓰기가 불가능하기 때문에, 띄어쓰기 역할을 대신 할 무언가가 필요합니다. 그 중 하나가 'camelCase'라는 것인데요. 첫 번째 글자는 소문자로 하고, 띄어쓰기가 있는 각 단어의 첫 문자를 대문자로 표기하는 방식입니다.



```js
var bad_variable_name; // 비추천 방식
var goodVariableName; // 추천 방식
```



중간 중간의 대문자가 낙타(camel)의 혹처럼 생겨서 camelCase라고 부릅니다.



# 참고 링크



JavaScript 코드를 쓸 때 추천하는 방식들을 정리해놓은 링크입니다:



- https://www.w3schools.com/js/js_conventions.asp
- https://github.com/tipjs/javascript-style-guide



두 문서에서도 camelCase를 선호하는 것을 확인할 수 있습니다.



# 자료형

> 변수와 상수에 넣는 데이터의 종류
>
> type of <변수명> 으로 자료형을 확인 가능 하다.



## I. 숫자형

대부분 프로그래밍 언어와 달리 자바 스크립트는 정수형과 소수형 모두 "number"라는 같은 숫자형 자료형으로 취급한다.

# Syntactic Sugar



자주 쓰이는 표현을 더 간략하게 쓸 수 있게 해주는 문법을 'syntactic sugar'라고 합니다.



'Syntactic'은 '문법적인'이란 뜻이고, 'sugar'는 아시다시피 '설탕'입니다. 직역을 하면 조금 이상하지만, [요즘 젊은 사람들의 표현을 빌리자면 코드를 간편하게 쓸 수 있기 때문에 '꿀'이라는 거죠!](https://namu.wiki/w/꿀#s-2)



### Assignment Operator



```js
// 다음 두 줄은 같은 의미입니다.
x = x + 1;
x += 1;

// 다음 두 줄은 같은 의미입니다.
x = x + 2;
x += 2;

// 다음 두 줄은 같은 의미입니다.
x = x * 2;
x *= 2;

// 다음 두 줄은 같은 의미입니다.
x = x - 3;
x -= 3;

// 다음 두 줄은 같은 의미입니다.
x = x / 2;
x /= 2;

// 다음 두 줄은 같은 의미입니다.
x = x % 7;
x %= 7;
```



규칙이 좀 보이시나요? 기존의 값에 연산을 해서 새로운 값으로 저장을 하는 경우, 위와 같이 짧게 줄여 쓸 수 있습니다.



### 증가 (increment), 감소 (decrement)



변수의 값을 `1`씩 증가시키거나 감소시킬 때에는 더욱더 간단하게 표현할 수 있습니다.



```js
// 다음 세 줄은 같은 의미입니다.
x = x + 1;
x += 1;
x++;

// 다음 세 줄은 같은 의미입니다.
x = x - 1;
x -= 1;
x--;
```



## 2. 문자열



## 3. 논리형





# 문자열과 배열

예전에 '문자열'을 배워보았는데요. 문자열도 생각해보면 '문자' + **'열'**이기 때문에 배열과 비슷한 속성들이 있습니다.



### 비슷한 점



배열처럼 대괄호로 인덱싱을 할 수 있습니다. 배열에서 0번 인덱스의 값과 1번 인덱스의 값을 출력하려고 하는 것처럼, 문자열의 0번 인덱스의 문자와 1번 인덱스의 문자를 출력해봅시다.



```js
var text1 = 'Hello';
console.log(text1[0]);
console.log(text1[1]);
```



```
H
e
```



마치 배열처럼 동작하죠? 실제로 아래처럼 배열로 만들어도 똑같은 결과값이 출력됩니다.



```js
var text2 = ['H', 'e', 'l', 'l', 'o'];
console.log(text2[0]);
console.log(text2[1]);
```



```
H
e
```



마찬가지로 배열의 길이를 받아오는 것과 문자열의 길이를 받아오는 것도 매우 유사합니다.



```js
var text1 = 'Hello';
var text2 = ['H', 'e', 'l', 'l', 'o'];
console.log(text1.length);
console.log(text2.length);
```



```
5
5
```



자바스크립트에서는 문자열을 단순히 `"Hello"`라는 한 덩어리로 보는 것이 아니라, 다섯 개의 알파벳 집합으로 받아들인다는 의미이죠. 이 점을 활용하면 문자열을 조금 더 자유자재로 다루실 수 있을 겁니다!



### 다른 점



물론 위의 `text1`과 `text2`가 완벽하게 동일한 것은 아닙니다. 엄연히 하나는 문자열이고 하나는 배열이니까요. `typeof`를 사용하면 이 사실을 확인할 수 있습니다.



```js
console.log(typeof text1)
console.log(typeof text2)
```



```
string
object
```



비교 연산자인 `==`을 사용해봐도 둘이 다르다는 걸 알 수 있습니다.



```js
console.log(text1 == text2);
```



```
false
```



이 둘은 각 글자에 접근하는 방식만 동일한 것이고, 엄연히 다른 존재입니다.



### mutable vs. immutable



또 다른 큰 차이점이 있습니다. 배열은 'mutable(바뀔 수 있는)' 자료형인 반면 문자열은 'immutable(바뀔 수 없는)' 자료형입니다.



첫 글자를 바꾸려 해보면, 배열인 `text1`의 첫 글자는 바뀌고 문자열인 `text2`의 첫 글자는 안 바뀝니다.



이런 차이는 에러로 이어질 수 있기 때문에 유의해서 사용해야 합니다.



```js
// 배열은 mutable
var text1 = ['h', 'e', 'l', 'l', 'o'];
text1[0] = 'b';
console.log(text1);

// 문자열은 immutable
var text2 = 'hello';
text2[0] = 'b';
console.log(text2);
```



```
["b", "e", "l", "l", "o"]
hello
```